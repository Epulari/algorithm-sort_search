/**
 * Created by Epulari T on 2018/8/6.
 */


/**
 * 插入排序：步长为1的希尔排序
 * 对插入排序进行修改：将插入排序的1变为gap，gap赋值1
 * 每轮内部比较时，将待排元素与已排序数比较，如果待排元素小于已排序数，则将已排序数向后移位，直到待排元素大于或等于某已排元素，则将待排元素放入到该元素后的空位
 *
 * @para = arr 数组
 */
function Shell_Insertion_Sort(arr) {
	var len = arr.length;
	if(len < 2) {
		return arr;
	}
	var gap = 1;
	//外层循环：一轮比较。每次已排序列多一个元素，i代表已排序列元素的最大索引，最开始只有一个元素arr[0]
	for(var i = gap; i < len; i++) {
		//待排元素
		var current = arr[i];
		//j为已排元素，最大取值为待排元素上一位
		var j = i - gap;
		//内层循环：进行每轮的单个元素比较。待排元素为已排元素的下一个值arr[i + 1]，即arr[j]，将之与已排元素进行比较并向后移位
		while(j >=0 && current < arr[j]) {
			arr[j + gap] = arr[j];
			j--;
		}
		//当不进入while循环内部时，避免同一个元素赋值给自身
		if (j + gap !== i) {
			arr[j + gap] = current;
		}
		console.log(arr);
	}
	return arr;
}

var arr = [7, 26, 53, 22, 32, 28, 38, 23, 24, 54, 27, 78, 33];
console.log("步长为1的希尔排序:");
Shell_Insertion_Sort(arr);

/**
 * result
	[ 7, 26, 53, 22, 32, 28, 38, 23, 24, 54, 27, 78, 33 ]
	[ 7, 26, 53, 22, 32, 28, 38, 23, 24, 54, 27, 78, 33 ]
	[ 7, 22, 26, 53, 32, 28, 38, 23, 24, 54, 27, 78, 33 ]
	[ 7, 22, 26, 32, 53, 28, 38, 23, 24, 54, 27, 78, 33 ]
	[ 7, 22, 26, 28, 32, 53, 38, 23, 24, 54, 27, 78, 33 ]
	[ 7, 22, 26, 28, 32, 38, 53, 23, 24, 54, 27, 78, 33 ]
	[ 7, 22, 23, 26, 28, 32, 38, 53, 24, 54, 27, 78, 33 ]
	[ 7, 22, 23, 24, 26, 28, 32, 38, 53, 54, 27, 78, 33 ]
	[ 7, 22, 23, 24, 26, 28, 32, 38, 53, 54, 27, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 32, 38, 53, 54, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 32, 38, 53, 54, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 32, 33, 38, 53, 54, 78 ]
 */


/**
 * 希尔排序
 * 在要排序的一组数中，根据某一增量分为若干子序列，对子序列分别进行插入排序
 * 逐渐减小增量并重复上诉过程，直至增量为1，此时序列基本有序，最后进行插入排序
 *
 * 根据上面的方法依次对gap进行赋值
 *
 * @para = arr 数组
 */
function ShellSort(arr) {
	var len = arr.length;
	if(len < 2) {
		return arr;
	}
	//间隔（步长）的值，取值方法之一：gap = 3 * gap + 1;
	var gap = 1;
	while(gap < len) {
		gap = 3 * gap + 1;
	}
	if (gap >= len) {
        gap = (gap - 1) / 3;
    }
	//步长为1时执行一次插入排序，然后结束排序
	while(gap > 0) {
		//外层循环：一轮比较。每次已排序列多一个元素，i代表已排序列元素的最大索引，最开始只有一个元素arr[0]
		console.log("gap=" + gap);
		for(var i = gap; i < len; i++) {
			//待排元素
			var current = arr[i];
			//j为已排元素，最大取值为待排元素上一位
			var j = i - gap;
			//内层循环：进行每轮的单个元素比较。待排元素为已排元素的下一个值arr[i + 1]，即arr[j]，将之与已排元素进行比较并向后移位
			while(j >=0 && current < arr[j]) {
				arr[j + gap] = arr[j];
				j -= gap;
			}
			//当不进入while循环内部时，避免同一个元素赋值给自身
			if (j + gap !== i) {
				arr[j + gap] = current;
			}
			console.log(arr);
		}
		console.log("本轮结果：" + arr);
		gap = (gap - 1) / 3;
	}
	return arr;
}

var arr = [7, 26, 53, 22, 32, 28, 38, 23, 24, 54, 27, 78, 33];
console.log("希尔排序:");
ShellSort(arr);

/**
 * result
	gap=13
	本轮结果:7,26,53,22,32,28,38,23,24,54,27,78,33
	gap=4
	[ 7, 26, 53, 22, 32, 28, 38, 23, 24, 54, 27, 78, 33 ]
	[ 7, 26, 53, 22, 32, 28, 38, 23, 24, 54, 27, 78, 33 ]
	[ 7, 26, 38, 22, 32, 28, 53, 23, 24, 54, 27, 78, 33 ]
	[ 7, 26, 38, 22, 32, 28, 53, 23, 24, 54, 27, 78, 33 ]
	[ 7, 26, 38, 22, 24, 28, 53, 23, 32, 54, 27, 78, 33 ]
	[ 7, 26, 38, 22, 24, 28, 53, 23, 32, 54, 27, 78, 33 ]
	[ 7, 26, 27, 22, 24, 28, 38, 23, 32, 54, 53, 78, 33 ]
	[ 7, 26, 27, 22, 24, 28, 38, 23, 32, 54, 53, 78, 33 ]
	[ 7, 26, 27, 22, 24, 28, 38, 23, 32, 54, 53, 78, 33 ]
	本轮结果:7,26,27,22,24,28,38,23,32,54,53,78,33
	gap=1
	[ 7, 26, 27, 22, 24, 28, 38, 23, 32, 54, 53, 78, 33 ]
	[ 7, 26, 27, 22, 24, 28, 38, 23, 32, 54, 53, 78, 33 ]
	[ 7, 22, 26, 27, 24, 28, 38, 23, 32, 54, 53, 78, 33 ]
	[ 7, 22, 24, 26, 27, 28, 38, 23, 32, 54, 53, 78, 33 ]
	[ 7, 22, 24, 26, 27, 28, 38, 23, 32, 54, 53, 78, 33 ]
	[ 7, 22, 24, 26, 27, 28, 38, 23, 32, 54, 53, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 38, 32, 54, 53, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 32, 38, 54, 53, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 32, 38, 54, 53, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 32, 38, 53, 54, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 32, 38, 53, 54, 78, 33 ]
	[ 7, 22, 23, 24, 26, 27, 28, 32, 33, 38, 53, 54, 78 ]
	本轮结果:7,22,23,24,26,27,28,32,33,38,53,54,78
 */