# 排序和搜索算法
## 排序算法
排序算法 | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度（辅助空间） | 排序方式 | 基本思想 | 稳定性
---- | ---- | ---- | ---- | ---- | ---- | ---- | ----
冒泡排序 | O(n<sup>2</sup>) | O(n) | O(n<sup>2</sup>) | O(1) | In-place | 交换排序 | 稳定
快速排序 | O(nlogn) | O(nlogn) | O(n<sup>2</sup>) | O(nlogn) | In-place | 交换排序 | 不稳定
插入排序 | O(n<sup>2</sup>) | O(n) | O(n<sup>2</sup>) | O(1) | In-place | 插入排序 | 稳定
希尔排序 | O(nlogn) | O(nlog<sup>2</sup>n) | O(nlog<sup>2</sup>n) | O(1) | In-place | 插入排序 | 不稳定
选择排序 | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(n<sup>2</sup>) | O(1) | In-place | 选择排序 | 不稳定
堆排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(1) | In-place | 选择排序 | 不稳定
归并排序 | O(nlogn) | O(nlogn) | O(nlogn) | O(n) | Out-place | 分治法 | 稳定
计数排序 | O(n+k) | O(n+k) | O(n+k) | O(k) | Out-place | 非比较排序 | 稳定
桶排序 | O(n+k) | O(n+k) | O(n<sup>2</sup>) | O(n+k) | Out-place | 非比较排序 | 稳定
基数排序 | O(n*k) | O(n*k) | O(n*k) | O(n+k) | Out-place | 非比较排序 | 稳定

**In/Out-place：**  
in-place：内部排序，数据记录在内存中进行排序；只需用到O(1)的额外空间的排序。冒泡排序、快速排序、插入排序、希尔排序、选择排序。  
Out-place：外部排序，因排序数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。归并排序、基数排序、计数排序、桶排序。  

**平均时间复杂度从低到高：**  
（1）计数排序O(n+k)、桶排序O(n+k)  
（2）基数排序O(n*k)  
（3）快速排序O(nlogn)、归并排序O(nlogn)、堆排序O(nlogn)、希尔排序O(nlogn)  
（4）插入排序O(n<sup>2</sup>)、冒泡排序O(n<sup>2</sup>)、选择排序O(n<sup>2</sup>)。  

### 冒泡排序 Bubble Sort
**基本思想：**  
　　In-place、交换排序。  
　　比较相邻的两个数，如果前者比后者大，则进行交换，每一轮排序后最后一个元素必然是最大的数。（如果数是按列排列，则较大的数下沉，较小的数冒起来。）  
**算法步骤：**  
　　1) 比较第1个和第2个元素，如果前者比后者大，则交换它们；  
　　2) 在上面的结果上比较第2个和第3个元素，如果前者比后者大，则交换它们；  
　　3) 按照上面的方式依次比较相邻元素，完成后最后的元素是最大的数；  
　　4) 排除上面结果的最后一个元素后重复上面的过程，直到没有任何一对数字需要比较。  
**时间复杂度：**  
　　最佳情况：T(n) = O(n)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(n<sup>2</sup>)，当输入的数据是反序时；  
　　平均情况：T(n) = O(n<sup>2</sup>)；  
　　稳定性：稳定；  
　　空间复杂度：O(1)。  

### 快速排序 Quick Sort
**基本思想：**  
　　In-place、交换排序。  
　　在待排序数据中选出一个元素（通常为第一个元素、最后一个元素或中间元素）作为基准，将其他元素与基准元素进行比较进而分成两部分，一部分比基准大，一部分比基准小；然后对这两部分分别按相同方法继续排列，直到每个部分只有1个数。  
　　事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。由于快速排序速度快、效率高，因此它是处理大数据最快的排序算法之一。  
**算法步骤：**  
　　1) 选择数组中最后一个元素作为基准；  
　　2) 从头开始遍历数组，将每个数与基准数比较，小于基准数的元素不动，将大于基准数的元素放到基准数的后面；  
　　3) 分别对基准数前和后的元素进行1-2步操作，直到每部分只有1个元素（递归）。  
**时间复杂度：**  
　　最佳情况：T(n) = O(nlogn)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(n<sup>2</sup>)，当输入的数据是反序时；  
　　平均情况：T(n) = O(nlogn)；  
　　稳定性：不稳定；  
　　空间复杂度：O(nlogn)。  

### 插入排序 Insertion Sort
**基本思想：**  
　　In-place、插入排序。  
　　扑克牌整理牌的顺序方式。一组乱序数据，设定前一半是已排好序的数，将剩余的数依次在已排好序的数中从后向前扫描找到对应位置并插入，如果待插入的元素与有序序列中的某个元素相等，则插入到相等元素后面。这个算法需要反复把已排好顺序的元素逐步向后挪动，为新元素提供插入空间。  
**算法步骤：**  
　　1) 认为第1个元素是已排好序的数；  
　　2) 取出第2个数，与第1个数（已排序数）比较，如果待排元素小于已排序数，则将已排序数向后移位，将待排元素放到已排序数的位置，否则不变；  
　　3) 取出下一个元素，与已排序数从后向前依次比较，如果待排元素小于已排序数，则将已排序数向后移位，直到待排元素大于或等于某已排元素，则将待排元素放入到该元素后的空位；  

　　4) 重复上一步骤，直到完成排序。  
**时间复杂度：**  
　　最佳情况：T(n) = O(n)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(n<sup>2</sup>)，当输入的数据是反序时；  
　　平均情况：T(n) = O(n<sup>2</sup>)；  
　　稳定性：稳定；  
　　空间复杂度：O(1)。  

### 希尔排序 Shell Sort
**基本思想：**  
　　In-place、插入排序。  
　　第一个突破O(n<sup>2</sup>)的排序算法；是简单插入排序的改进版，与插入排序的不同处在于，它是优先比较距离较远的元素。希尔排序又被称作缩小增量排序/递减增量排序算法。  
　　在要排序的一组数中，根据某一增量分为若干子序列，对子序列分别进行插入排序。逐渐减小增量并重复上诉过程，直至增量为1，此时序列基本有序，最后进行插入排序。  
**算法步骤：**  
　　1) 取一个增量k，每隔k个数的元素组成一个子序列，则原数组分成干子序列；  
　　2) 在子序列中进行插入排序，子序列顺序的改变，导致原数组下标对应的元素值改变了；  
　　3) 减小增量k，重复上述步骤，直至k为1，再进行一次插入排序则完成排序。  
**时间复杂度：**  
　　最佳情况：T(n) = O(nlog<sup>2</sup>n)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(nlog<sup>2</sup>n)，当输入的数据是反序时；  
　　平均情况：T(n) = O(nlogn)；  
　　稳定性：不稳定；  
　　空间复杂度：O(1)。  

### 选择排序 Selection Sort
**基本思想：**  
　　In-place、选择排序。  
　　依次选出数组最小的数进行重新排列构建为有序数组。  
**算法步骤：**  
　　1) 初始有待排序列和空序列；  
　　2) 假设待排序列第一个元素为最小值，从第二个元素开始依次与之比较和交换，找到数组中的最小值，追加到空序列中；  
　　3) 重复第二步，直到所有元素均排序完毕。  
**时间复杂度：**  
　　最佳情况：T(n) = O(n<sup>2</sup>)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(n<sup>2</sup>)，当输入的数据是反序时；  
　　平均情况：T(n) = O(n<sup>2</sup>)；  
　　稳定性：不稳定；  
　　空间复杂度：O(1)。  

### 堆排序 Heap Sort
**基本思想：**  
　　In-place、选择排序。  
　　利用堆这种数据结构所设计的一种排序算法。  
　　数组从左至右与堆从上到下从左至右一一对应。堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。  
　　大顶堆：arr[i](父节点) >= arr[2i+1](左子节点) && arr[i] >= arr[2i+2](右子节点)   
　　小顶堆：arr[i](父节点) <= arr[2i+1](左子节点) && arr[i] <= arr[2i+2](右子节点)   
**算法步骤：**  
　　1) 构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)：从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 arr.length/2-1），从左至右，从下至上进行调整;  
　　2) 将堆顶元素与末尾元素进行交换，使末尾元素最大；  
　　3) 重复上述步骤，直到整个序列有序。  
**时间复杂度：**  
　　最佳情况：T(n) = O(nlogn)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(nlogn)，当输入的数据是反序时；  
　　平均情况：T(n) = O(nlogn)；  
　　稳定性：不稳定；  
　　空间复杂度：O(1)。  

### 归并排序 Merge Sort
**基本思想：**  
　　Out-place。  
　　该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。  
　　依次选出数组最小的数进行重新排列构建为有序数组。先使每个子序列有序，再使子序列段间有序，将已有序的子序列合并，得到完全有序的序列。  
**算法步骤：**  
　　1) 将数组根据len/2分成两个序列，直到每个序列只有一个元素;  
　　2) 将子序列进行比较合并，替代原父序列，直到还原成替换数组的序列，该序列有序。  
**时间复杂度：**  
　　最佳情况：T(n) = O(nlogn)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(nlogn)，当输入的数据是反序时；  
　　平均情况：T(n) = O(nlogn)；  
　　稳定性：稳定；  
　　空间复杂度：O(n)。  

### 计数排序 Counting Sort
**基本思想：**  
　　Out-place、计数排序、非比较的排序算法。  
　　计数排序对一定量的整数排序时候的速度非常快，一般快于其他排序算法。但计数排序局限性比较大，只限于对整数进行排序。  
　　对于一个输入数组中的一个元素x，只要我们知道了这个数组中比x小的元素的个数，那么我们就可以直接把x放到（x+1）的位置上。  
**算法步骤：**  
　　1) 找出数组中的最大值和最小值;  
　　2) 统计数组中每个值i的元素出现的次数，将其存入新数组的第i项；  
　　3) 将上面的数组根据索引i的值依次在新数组中展开索引i，其结果则为有序数组。  
**时间复杂度：**  
　　最佳情况：T(n) = O(n+k)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(n+k)，当输入的数据是反序时；  
　　平均情况：T(n) = O(n+k)；  
　　稳定性：稳定；  
　　空间复杂度：O(k)。  

### 桶排序 Bucket Sort
**基本思想：**  
　　Out-place、计数排序、非比较的排序算法。  
　　桶排序是计数排序的升级版。它利用了函数的映射关系（比较规则），高效与否的关键就在于这个映射函数的确定。  
**算法步骤：**  
　　1) 根据规则创建多个桶，并为桶编号序号;  
　　2) 根据规则将各个数据放入对应的桶中；  
　　3) 根据序号依次将桶内数据放回数组中；  
　　4) 重复上述步骤直到序列有序。  
例如，对数字进行排序（不含负数，如果是负数还要判定负号）：  
　　1) 创建10个桶，根据个位数依次放入对应的桶中;  
　　2) 根据序号依次将桶内数据放回数组中；  
　　3) 根据十位数、百位数等重复上述步骤，最后一次放回数组时序列有序。  
例如，对相同固定长度的字符串进行排序（只考虑全小写）：  
　　1) 根据26个字母创建26个桶，根据最后一个字母依次放入对应的桶中;  
　　2) 根据序号依次将桶内数据放回数组中；  
　　3) 根据倒数第二位字母、倒数第三位字母等重复上述步骤，最后一次放回数组时序列有序。  
**时间复杂度：**  
　　最佳情况：T(n) = O(n+k)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(n<sup>2</sup>)，当输入的数据是反序时；  
　　平均情况：T(n) = O(n+k)；  
　　稳定性：稳定；  
　　空间复杂度：O(n+k)。  

### 基数排序 Radix Sort
**基本思想：**  
　　Out-place、桶排序、非比较的排序算法。  
　　依次选出数组最小的数进行重新排列构建为有序数组。  
**算法步骤：**  
　　  
**时间复杂度：**  
　　最佳情况：T(n) = O(n*k)，当输入的数据已经是正序时；  
　　最差情况：T(n) = O(n*k)，当输入的数据是反序时；  
　　平均情况：T(n) = O(n*k)；  
　　稳定性：稳定；  
　　空间复杂度：O(n+k)。  

## 搜索算法